package com.ucuenca.misctools;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.row.RowMeta;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.core.row.ValueMetaInterface;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.StepMetaInterface;

/**
 * Creates a DataBase loader to precatch data (that a PDI step will generate )
 * into a DataBase Schema.
 *
 * @author santteegt
 *
 */
public class StepDataLoader {

    /**
     * RowMeta associated with the step
     */
    private RowMetaInterface outputRowMeta;
    /**
     * PDI Step to precatch data
     */
    private BaseStep step;
    /**
     * PDI Step name
     */
    private String stepName;
    /**
     * Boolean.TRUE if step will call the DB loading process
     */
    private Boolean databaseLoad = Boolean.FALSE;
    /**
     * Table name where the process load data *
     */
    private String tableName;
    /**
     * Boolean.TRUE if the instacne has already created the table
     */
    private Boolean createdTable = Boolean.FALSE;
    /**
     * List of table fields with its associated constraints. For table creation
     * and insertion purposes.
     */
    private Map<String, String> tableFields;
    /**
     * SQL DML sentence for insertion processes
     */
    private String sqlInsertion;
    /**
     * Current table row sequence
     */
    public Integer sequence;

    public StepDataLoader(String tableName) {
        this.tableName = tableName;
        sequence = 0;
    }

    public RowMetaInterface getOutputRowMeta() {
        return this.outputRowMeta;
    }

    public void setOutputRowMeta(RowMetaInterface outputRowMeta) {
        this.outputRowMeta = outputRowMeta;
    }

    public String getStepName() {
        return this.stepName;
    }

    public void setStepName(String stepName) {
        this.stepName = stepName;
    }

    public Boolean getDatabaseLoad() {
        return this.databaseLoad;
    }

    public void setDatabaseLoad(Boolean databaseLoad) {
        this.databaseLoad = databaseLoad;
    }

    /**
     * Gets the PDI step row metadata
     *
     * @param smi Step metadata class
     * @return Row metadata
     * @throws KettleException
     */
    public RowMetaInterface getMetaFieldsDef(StepMetaInterface smi) throws KettleException {
        //OAILoaderMeta meta = (OAILoaderMeta) smi;
        outputRowMeta = new RowMeta();
        smi.getFields(outputRowMeta, this.stepName, null, null, null, null, null);
        return outputRowMeta;
    }

    public void setBaseStep(BaseStep step) {
        this.step = step;
    }

    public BaseStep getBaseStep() {
        return this.step;
    }

    /**
     * Creates a map with table fields and their associated constraints
     *
     * @param smi Step metadata class
     * @return map with table fields and their associated constraints
     * @throws Exception
     */
    private Map<String, String> getFields(StepMetaInterface smi) throws Exception {
        if (tableFields == null) {
            tableFields = new LinkedHashMap<String, String>();
            tableFields.put("TRANSID", "VARCHAR(50)");
            tableFields.put("STEPID", "VARCHAR(50)");
            tableFields.put("SEQUENCE", "INTEGER");
            if (outputRowMeta == null) {
                this.getMetaFieldsDef(smi);
            }
            for (ValueMetaInterface fieldMeta : outputRowMeta.getValueMetaList()) {
                String fieldName = fieldMeta.getName().toUpperCase().replaceAll(" ", "_");
                String definition = "";
                switch (fieldMeta.getType()) {
                    case ValueMetaInterface.TYPE_INTEGER: {

                    }
                    default: { //Manage any other field type as String
                        int length = fieldMeta.getLength();
                        if (length < 0 ){
                            length=0;
                        }
                        definition = "VARCHAR(" + "0" + ")";
                    }
                }
                tableFields.put(fieldName, definition);
            }
            tableFields.put("PRIMARY KEY", "(TRANSID, STEPID, SEQUENCE)");
        }
        return this.tableFields;
    }

    public void init_(StepMetaInterface smi, Object[] values) throws Exception {
        if (!createdTable) {
            DatabaseLoader.createTable(tableName, this.getFields(smi), false);
            createdTable = Boolean.TRUE;
            this.cleanTableStepData(new Object[]{values[0], values[1]});
        }

    }

    /**
     * Insert a data row into table schema
     *
     * @param smi Step metadata class
     * @param values Row Values generated by the PDI Step
     * @throws Exception
     */
    public void insertTableRow(StepMetaInterface smi, Object[] values) throws Exception {
        if (!createdTable) {
            DatabaseLoader.createTable(tableName, this.getFields(smi), false);
            createdTable = Boolean.TRUE;
            this.cleanTableStepData(new Object[]{values[0], values[1]});
        }
        try {
            int totalFields = values.length;
            this.sqlInsertion = "INSERT INTO " + tableName + " VALUES(";
            while (--totalFields >= 1) {
                this.sqlInsertion += "?,";
            }
            this.sqlInsertion += "?)";
            DatabaseLoader.executeUpdate(this.sqlInsertion, values);
            this.logDebug(this.sqlInsertion, values);
        } catch (Exception e) {
            logBasic("ERROR EXECUTING SQL INSERT: " + e.getMessage());
        }
    }

    /**
     * Delete all data previously associated with the PDI transformation
     *
     * @param pkValues
     * @return
     * @throws Exception
     */
    private Boolean cleanTableStepData(Object[] pkValues) throws Exception {
        return DatabaseLoader.executeUpdate("DELETE FROM " + tableName + " WHERE TRANSID = ? AND STEPID = ?", pkValues);
    }

    /**
     * Logging options for StepData classes
     *
     * @param message
     * @param throwException
     * @throws KettleException
     */
    public void logBasic(String message, Boolean... throwException) throws KettleException {
        if (!databaseLoad && step != null) {
            step.logBasic(message);
        } else {
            System.out.println(message);
        }
        if (throwException.length > 0 && throwException[0]) {
            throw new KettleException(message);
        }

    }

    /**
     * Logging options for StepData classes
     *
     * @param message
     * @param throwException
     * @throws KettleException
     */
    public void logDebug(String message, Object... arguments) throws KettleException {
        if (!databaseLoad && step != null && step.isDebug()) {
            step.logDebug(message, arguments);
        }
    }

};
